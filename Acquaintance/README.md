# ***Тема №2: Знакомство с алгоритмами***
<div align="center">
  <img alt="Foto1" src="./Image/image1.png" width="500" height="450"/>
</div>

# ***Оглавление***
1. [Бинарный поиск](#бинарнй-поиск)
2. [Горный массив](#горный-массив) 
3. [Связанные списки](#связанные-списки)
4. [Решето Эратосфена](#решето-эратосфенав)
5. [Решето Сундарамы](#решето-сундарамы) 
6. Заключение

## **Бинарнй поиск**

Представьте, что у вас есть отсортированный массив, например, `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`, и ваша задача — найти, под каким индексом спряталось число 10. После каждой вашей догадки вам говорят одно из трёх: «больше», «меньше» или «угадали».

Если вы решите проверять элементы по порядку, с первого по последний, сколько проверок вам потребуется? **Ровно 10**. А если массив увеличится до 100 или 1000 элементов, и нужно будет найти последний, то вы сделаете **100 или 1000 проверок** соответственно. Такой подход, известный как **линейный поиск**, действительно надёжен, но очень медленен, и **его сложность описывается как O(n)**. С ростом размера массива время работы растёт прямо пропорционально.

**Бинарный поиск** — это изящный алгоритм, который решает ту же задачу гораздо эффективнее. **Его суть в том, чтобы постоянно делить область поиска пополам**. Вы начинаете не с края, а с **элемента посередине**. В зависимости от ответа («больше» или «меньше») вы **отбрасываете одну из половин массива** и повторяете проверку для оставшейся части.

**Давайте найдём число 10 в нашем массиве, используя эту стратегию:**

- Проверка 1: Берём средний элемент — 5. Ответ: «10 больше, чем 5». Отбрасываем левую половину.
- Проверка 2: В оставшейся части `[6, 7, 8, 9, 10]` средний элемент — 8. Ответ: «10 больше, чем 8». Снова отбрасываем левую часть.
- Проверка 3: Теперь массив `[9, 10]`. Проверяем 9. Ответ: «10 больше, чем 9». Двигаемся дальше.
- Проверка 4: Остался один элемент — 10. Ответ: «Угадали!».

**Вместо 10 проверок нам понадобилось всего 4**.**Сложность этого алгоритма — O(log n)**. Для массива из 10 элементов log 10 ≈ 3.32, значит, в худшем случае потребуется 4 итерации.

Теперь представьте массив из 1024 элементов. Линейный поиск в худшем случае сделает **1024 проверки**. Бинарный же поиск справится с задачей за **log 1024 = 10 проверок**. **Это более чем в 100 раз быстрее!** И чем больше массив, тем внушительнее становится эта разница, делая бинарный поиск **незаменимым инструментом для работы с отсортированными данными**.

```go
package main

import "fmt"

func main() {
	var n, per int
	fmt.Print("Введите размер массива n: ")
	fmt.Scan(&n)
	fmt.Print("Введите значение элемента, которое ищем per: ")
	fmt.Scan(&per)
	arr := make([]int, n)

	for i := 0; i < n; i++ {
		arr[i] = i + 1
	}

	left, right := 0, n-1
	k := 0

	for left <= right {
		k++
		mid := (left + right) / 2

		if arr[mid] == per {
			fmt.Printf("Количество проверок k = %d \n", k)
			return
		} else if arr[mid] < per {
			left = mid + 1
		} else {
			right = mid - 1
		}
	}
}
```

*Пример работы кода*

```
Введите размер массива n: 65000
Введите значение элемента, которое ищем per: 34567
Количество проверок k = 16
```

[Вернуться к оглавлению](#оглавление)

## ***Горный массив***

<div align="center">
  <img alt="Foto1" src="./Image/image2.png" width="500" height="450"/>
</div>

Тема бинарного поиска находит своё продолжение в задаче о «Горном массиве» (Mountain Array). Это модификация классического алгоритма, которая оттачивает навыки анализа и применения бинарного поиска в нестандартных условиях.

**Что же такое Горный массив?**

Это особый вид массива, который визуально напоминает подножье, склон и вершину горы.

- Восхождение: Сначала элементы массива строго возрастают до определённой точки.
- Вершина (Пик): Достигается максимальный элемент, после которого направление меняется.
- Спуск: После пика элементы массива строго убывают.

**Обязательные условия:**

- Массив должен содержать не менее трёх элементов.
- В массиве не может быть нескольких пиков — лишь одна единственная вершина.

**Рассмотрим пример: `[1, 5, 8, 11, 20, 17, 13, 6, 3]`**

**В этом массиве:**

- Элементы последовательно возрастают: `1 → 5 → 8 → 11 → 20`
- Пиком является число `20`.
- После пика элементы убывают: `20 → 17 → 13 → 6 → 3`

**Данный код не проверяет массив на горность, а лишь находит пик!**

```go
package main

import "fmt"

func main() {
	var n int
	fmt.Print("Введите размер массива n > 2: ")
	fmt.Scan(&n)
	arr := make([]int, n)

	fmt.Print("Вводите элементы массива n раз: ")
	for i := 0; i < n; i++ {
		fmt.Scan(&arr[i])
	}

	fmt.Printf("Горный массив arr: %d\n", arr)
	left, right := 0, n-1

	for left < right {
		mid := (left + right) / 2

		if arr[mid] < arr[mid+1] {
			left = mid + 1
		} else {
			right = mid
		}
	}

	fmt.Printf("Индекс пика: %d\n", right)
	fmt.Printf("Значение пика: %d\n", arr[right])
}
```

*Пример работы кода*

```
Введите размер массива n > 2: 9
Вводите элементы массива n раз: 1 5 8 11 20 17 13 6 3
Горный массив arr: [1 5 8 11 20 17 13 6 3]
Индекс пика: 4
Значение пика: 20
```

[Вернуться к оглавлению](#оглавление)

## ***Связанные списки*** 

Мы уже знакомы с массивами, у которых есть общая проблема — **жесткость размера**. Даже динамические массивы при расширении вынуждены переезжать в памяти и копировать все элементы.

Но существует структура, которая решает эту проблему принципиально иначе — **связанные списки**.

**Как связанный список устроен в памяти?**

Представьте цепочку записок-загадок. В первой записке лежит число и подсказка: «Ищи следующую записку в ящике №105». Вы идете к ящику 105, находите новую записку с числом и указанием на ящик №23, и так далее.

**Каждый элемент списка (узел) содержит:**

- Данные (ваше число)
- Указатель (адрес следующего узла)

Эти узлы **разбросаны по памяти в произвольном порядке** и связаны только этими указателями.

**Главное преимущество:** Чтобы вставить новый элемент в середину, не нужно двигать остальные! Достаточно:

- Создать новую «записку» где угодно в памяти
- Перенаправить указатели: предыдущий узел теперь ссылается на новый, а новый — на следующий

**Плата за гибкость:** Вы не можете мгновенно получить доступ к 10-му элементу, как в массиве. Придется пройти всю цепочку с самого начала.

Таким образом, связанные списки жертвуют скоростью произвольного доступа ради **мгновенных вставок и удалений** в любом месте без перекопирования данных.

```go
package main

import "fmt"

type Node struct {
	val  string
	next *Node
}

func main() {
	node1 := &Node{val: "Перый узел", next: nil}

	node2 := &Node{val: "Второй узел", next: nil}
	node1.next = node2

	node3 := &Node{val: "Третий узел", next: nil}
	node2.next = node3

	current := node1
	for current != nil {
		fmt.Print(current.val, " → ")
		current = current.next
	}
	fmt.Println("nil")
}
```

*Пример работы кода*

```
Перый узел → Второй узел → Третий узел → nil
```

[Вернуться к оглавлению](#оглавление)

## ***Решето Эратосфена***

**Погрузимся в мир простых чисел — фундаментальных строительных блоков всей математики.** Именно на них основана современная криптография, обеспечивающая безопасность интернет-соединений, электронной почты и банковских транзакций. Основная теорема арифметики гласит, что любое натуральное число можно единственным образом представить в виде произведения простых чисел. Давайте освоим эффективный способ нахождения этих математических "кирпичиков"!

**Что такое решето Эратосфена?**

Решето Эратосфена — это эффективный алгоритм для нахождения всех простых чисел до заданного предела N.

**Сложность этого алгоритма — O(n log log n)**

**Как работает алгоритм:**

1. Создаём список чисел от 2 до N
2. Начинаем с первого простого числа (2) и вычеркиваем все числа, кратные ему
3. Переходим к следующему невычеркнутому числу
4. Повторяем до тех пор, пока квадрат текущего числа не превысит N

**Рассмотрим пример для N = 30**

```go
package main

import "fmt"

func main() {
	var n int
	fmt.Print("Введите до какого числа N ищете простые числа: ")
	fmt.Scan(&n)
	prime := make([]bool, n+1)

	for i := 2; i <= n; i++ {
		prime[i] = true
	}

	for i := 2; i*i <= n; i++ {
		if prime[i] {
			for j := i * i; j <= n; j += i {
				prime[j] = false
			}
		}
	}

	fmt.Print("Простые числа: ")
	for i := 2; i <= n; i++ {
		if prime[i] {
			fmt.Print(i, " ")
		}
	}
}
```

*Что происходит*

```
Исходный ряд: 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30

После 2:      2 3 - 5 - 7 - 9 -  11 -  13 -  15 -  17 -  19 -  21 -  23 -  25 -  27 -  29 -
После 3:      2 3 - 5 - 7 - - -  11 -  13 -  -  -  17 -  19 -  -  -  23 -  25 -  -  -  29 -
После 5:      2 3 - 5 - 7 - - -  11 -  13 -  -  -  17 -  19 -  -  -  23 -  -  -  -  -  29 -

Результат:    2 3   5   7        11    13          17    19          23                29
```

*Пример работы кода*

```
Введите до какого числа N ищете простые числа: 30
Простые числа: 2 3 5 7 11 13 17 19 23 29 
```

[Вернуться к оглавлению](#оглавление)

## ***Решето Сундарамы***