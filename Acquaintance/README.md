# ***Тема №2: Знакомство с алгоритмами***
<div align="center">
  <img alt="Foto1" src="./Image/image1.png" width="500" height="400"/>
</div>

# ***Оглавление***
1. [Бинарный поиск](#бинарнй-поиск)
2. Горный массив 
3. Связанные списки
4. Решето Эратосфена 
5. Решето Сундарамы 
6. Итоги

## **Бинарнй поиск**

Представьте, что у вас есть отсортированный массив, например, `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`, и ваша задача — найти, под каким индексом спряталось число 10. После каждой вашей догадки вам говорят одно из трёх: «больше», «меньше» или «угадали».

Если вы решите проверять элементы по порядку, с первого по последний, сколько проверок вам потребуется? Ровно 10. А если массив увеличится до 100 или 1000 элементов, и нужно будет найти последний, то вы сделаете 100 или 1000 проверок соответственно. Такой подход, известный как линейный поиск, действительно надёжен, но очень медленен, и его сложность описывается как O(n). С ростом размера массива время работы растёт прямо пропорционально.

Бинарный поиск — это изящный алгоритм, который решает ту же задачу гораздо эффективнее. Его суть в том, чтобы постоянно делить область поиска пополам. Вы начинаете не с края, а с элемента посередине. В зависимости от ответа («больше» или «меньше») вы отбрасываете одну из половин массива и повторяете проверку для оставшейся части.

Давайте найдём число 10 в нашем массиве, используя эту стратегию:

- Проверка 1: Берём средний элемент — 5. Ответ: «10 больше, чем 5». Отбрасываем левую половину.

- Проверка 2: В оставшейся части `[6, 7, 8, 9, 10]` средний элемент — 8. Ответ: «10 больше, чем 8». Снова отбрасываем левую часть.

- Проверка 3: Теперь массив `[9, 10]`. Проверяем 9. Ответ: «10 больше, чем 9». Двигаемся дальше.

- Проверка 4: Остался один элемент — 10. Ответ: «Угадали!».

Вместо 10 проверок нам понадобилось всего 4. Сложность этого алгоритма — O(log₂n). Для массива из 10 элементов log₂10 ≈ 3.32, значит, в худшем случае потребуется 4 итерации.

Теперь представьте массив из 1024 элементов. Линейный поиск в худшем случае сделает 1024 проверки. Бинарный же поиск справится с задачей за log₂1024 = 10 проверок. Это более чем в 100 раз быстрее! И чем больше массив, тем внушительнее становится эта разница, делая бинарный поиск незаменимым инструментом для работы с отсортированными данными.

```go
package main

import "fmt"

func main() {
	var n, per int
	fmt.Print("Введите размер массива n: ")
	fmt.Scan(&n)
	fmt.Print("Введите значение элемента, которое ищем per: ")
	fmt.Scan(&per)
	arr := make([]int, n)

	for i := 0; i < n; i++ {
		arr[i] = i + 1
	}

	left, right := 0, n-1
	k := 0

	for left <= right {
		k++
		mid := (left + right) / 2

		if arr[mid] == per {
			fmt.Printf("Количество проверок k = %d \n", k)
			return
		} else if arr[mid] < per {
			left = mid + 1
		} else {
			right = mid - 1
		}
	}
}
```

*Пример работы:*

```
Введите размер массива n: 65000
Введите значение элемента, которое ищем per: 34567
Количество проверок k = 16
```

[Вернуться к оглавлению](#оглавление)

