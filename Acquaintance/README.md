# ***Тема №2: Знакомство с алгоритмами***
<div align="center">
  <img alt="Foto1" src="./Image/image1.png" width="500" height="450"/>
</div>

# ***Оглавление***
1. [Бинарный поиск](#бинарнй-поиск)
2. [Горный массив](#горный-массив) 
3. Связанные списки
4. Решето Эратосфена 
5. Решето Сундарамы 
6. Заключение

## **Бинарнй поиск**

Представьте, что у вас есть отсортированный массив, например, `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`, и ваша задача — найти, под каким индексом спряталось число 10. После каждой вашей догадки вам говорят одно из трёх: «больше», «меньше» или «угадали».

Если вы решите проверять элементы по порядку, с первого по последний, сколько проверок вам потребуется? Ровно 10. А если массив увеличится до 100 или 1000 элементов, и нужно будет найти последний, то вы сделаете 100 или 1000 проверок соответственно. Такой подход, известный как линейный поиск, действительно надёжен, но очень медленен, и его сложность описывается как O(n). С ростом размера массива время работы растёт прямо пропорционально.

Бинарный поиск — это изящный алгоритм, который решает ту же задачу гораздо эффективнее. Его суть в том, чтобы постоянно делить область поиска пополам. Вы начинаете не с края, а с элемента посередине. В зависимости от ответа («больше» или «меньше») вы отбрасываете одну из половин массива и повторяете проверку для оставшейся части.

Давайте найдём число 10 в нашем массиве, используя эту стратегию:

- Проверка 1: Берём средний элемент — 5. Ответ: «10 больше, чем 5». Отбрасываем левую половину.

- Проверка 2: В оставшейся части `[6, 7, 8, 9, 10]` средний элемент — 8. Ответ: «10 больше, чем 8». Снова отбрасываем левую часть.

- Проверка 3: Теперь массив `[9, 10]`. Проверяем 9. Ответ: «10 больше, чем 9». Двигаемся дальше.

- Проверка 4: Остался один элемент — 10. Ответ: «Угадали!».

Вместо 10 проверок нам понадобилось всего 4. Сложность этого алгоритма — O(log₂n). Для массива из 10 элементов log₂10 ≈ 3.32, значит, в худшем случае потребуется 4 итерации.

Теперь представьте массив из 1024 элементов. Линейный поиск в худшем случае сделает 1024 проверки. Бинарный же поиск справится с задачей за log₂1024 = 10 проверок. Это более чем в 100 раз быстрее! И чем больше массив, тем внушительнее становится эта разница, делая бинарный поиск незаменимым инструментом для работы с отсортированными данными.

```go
package main

import "fmt"

func main() {
	var n, per int
	fmt.Print("Введите размер массива n: ")
	fmt.Scan(&n)
	fmt.Print("Введите значение элемента, которое ищем per: ")
	fmt.Scan(&per)
	arr := make([]int, n)

	for i := 0; i < n; i++ {
		arr[i] = i + 1
	}

	left, right := 0, n-1
	k := 0

	for left <= right {
		k++
		mid := (left + right) / 2

		if arr[mid] == per {
			fmt.Printf("Количество проверок k = %d \n", k)
			return
		} else if arr[mid] < per {
			left = mid + 1
		} else {
			right = mid - 1
		}
	}
}
```

*Пример работы*

```
Введите размер массива n: 65000
Введите значение элемента, которое ищем per: 34567
Количество проверок k = 16
```

[Вернуться к оглавлению](#оглавление)

## ***Горный массив***
<div align="center">
  <img alt="Foto1" src="./Image/image2.png" width="500" height="450"/>
</div>

Тема бинарного поиска находит своё продолжение в задаче о «Горном массиве» (Mountain Array). Это модификация классического алгоритма, которая оттачивает навыки анализа и применения бинарного поиска в нестандартных условиях.

Что же такое Горный массив?

Это особый вид массива, который визуально напоминает подножье, склон и вершину горы. 

- Восхождение: Сначала элементы массива строго возрастают до определённой точки.

- Вершина (Пик): Достигается максимальный элемент, после которого направление меняется.

- Спуск: После пика элементы массива строго убывают.

Обязательные условия:

- Массив должен содержать не менее трёх элементов.

- В массиве не может быть нескольких пиков — лишь одна единственная вершина.

Рассмотрим пример: `[1, 5, 8, 11, 20, 17, 13, 6, 3]`

В этом массиве:

- Элементы последовательно возрастают: `1 → 5 → 8 → 11 → 20`

- Пиком является число `20`.

- После пика элементы убывают: `20 → 17 → 13 → 6 → 3`

**Данный код не проверяет массив на горность, а лишь находит пик!**

```go
package main

import "fmt"

func main() {
	var n int
	fmt.Print("Введите размер массива n > 2: ")
	fmt.Scan(&n)
	arr := make([]int, n)

	fmt.Print("Вводите элементы массива n раз: ")
	for i := 0; i < n; i++ {
		fmt.Scan(&arr[i])
	}

	fmt.Printf("Горный массив arr: %d\n", arr)
	left, right := 0, n-1

	for left < right {
		mid := (left + right) / 2

		if arr[mid] < arr[mid+1] {
			left = mid + 1
		} else {
			right = mid
		}
	}

	fmt.Printf("Индекс пика: %d\n", right)
	fmt.Printf("Значение пика: %d\n", arr[right])
}
```

*Пример работы*

```
Введите размер массива n > 2: 9
Вводите элементы массива n раз: 1 5 8 11 20 17 13 6 3
Горный массив arr: [1 5 8 11 20 17 13 6 3]
Индекс пика: 4
Значение пика: 20
```