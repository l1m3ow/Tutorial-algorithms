# ***Тема №3: Алгоритмы сортировок***
<div align="center">
  <img alt="Foto 1" src="Image/image1.png" width="600" height="400"/>
</div>

---

Алгоритмы сортировки — это фундаментальные процедуры в компьютерных науках, предназначенные для упорядочивания элементов данных в определённом порядке, что критически важно для эффективного выполнения последующих операций, таких как быстрый поиск, анализ данных и оптимизация работы приложений. Их важность невозможно переоценить, поскольку они лежат в основе бесчисленного множества систем — от баз данных и файловых менеджеров до сложных алгоритмов машинного обучения, напрямую влияя на производительность, отзывчивость и общую эффективность вычислительных процессов в современном цифровом мире.

# ***Оглавление***

1. [Пузырьковая сортировка](#пузырьковая-сортировка)
2. [Шейкерная сортировка](#шейкерная-сортировка)
3. [Сортировка вставками](#сортировка-вставками)
4. [Сортировка выбором](#сортировка-выбором)
5. [Сортировка алгоритмом шелла](#сортировка-алгоритмом-шелла)
6. [Гномья сортировка](#быстрая-сортировка)
7. [Заключение](#заключение)

## ***Пузырьковая сортировка***
<div align="center">
  <img alt="Foto 2" src="Image/image2.png" width="700" height="350"/>
</div>

---

Пузырьковая сортировка — это простой алгоритм, который многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. Этот процесс повторяется до тех пор, пока массив не будет полностью отсортирован, а "всплывающие" более крупные элементы постепенно перемещаются в конец массива, как пузырьки.

```go
func Bubble(arr []int) {
	fmt.Println("\n---Пузырьковая сортировка---")

	size := len(arr)

	for j := 0; j < size-1; j++ {
		swap := false

		for k := 0; k < size-1-j; k++ {
			if arr[k] > arr[k+1] {
				arr[k], arr[k+1] = arr[k+1], arr[k]
				swap = true
			}
		}

		if !swap {
			break
		}
	}
	fmt.Println("Отсортированный массив:", arr)
}
```

[Вернуться к оглавлению](#оглавление)

## ***Шейкерная сортировка***
<div align="center">
  <img alt="Foto 3" src="Image/image3.png" width="700" height="350"/>
</div>

---

Шейкерная сортировка (сортировка перемешиванием) — это улучшенная версия пузырьковой сортировки, которая проходит массив в обоих направлениях: слева направо и справа налево. На каждом проходе наибольшие элементы "всплывают" в конец, а наименьшие "оседают" в начале, что ускоряет процесс сортировки.

```go
func Shaker(arr []int) {
	fmt.Println("\n---Шейкерная сортировка---")

	size := len(arr)
	left := 0
	right := size - 1
	step := 1

	for left < right {
		for i := left; i < right; i++ {
			if arr[i] > arr[i+1] {
				arr[i], arr[i+1] = arr[i+1], arr[i]
			}
		}

		right--
		step++

		for i := right; i > left; i-- {
			if arr[i] < arr[i-1] {
				arr[i], arr[i-1] = arr[i-1], arr[i]
			}
		}

		left++
		step++
	}

	fmt.Println("Отсортированный массив:", arr)
}
```

[Вернуться к оглавлению](#оглавление)

## ***Сортировка вставками***
<div align="center">
  <img alt="Foto 4" src="Image/image4.png" width="700" height="350"/>
</div>

---

Сортировка вставками — это простой алгоритм, который строит отсортированную часть массива по одному элементу за раз, аналогично тому, как мы сортируем карты в руке. На каждом шаге алгоритм берёт очередной элемент и вставляет его на правильную позицию в уже отсортированной части массива.

```go
func Inserts(arr []int) {
	fmt.Println("\n---Сортировка вставками---")

	size := len(arr)

	for i := 1; i < size; i++ {
		per := arr[i]
		j := i - 1
		for j >= 0 && arr[j] > per {
			arr[j+1] = arr[j]
			j--
		}
		arr[j+1] = per
	}

	fmt.Println("Отсортированный массив:", arr)
}
```

[Вернуться к оглавлению](#оглавление)

## ***Сортировка выбором***
<div align="center">
  <img alt="Foto 5" src="Image/image5.png" width="600" height="400"/>
</div>

---

Сортировка выбором — это алгоритм, который на каждом проходе находит минимальный (или максимальный) элемент в неотсортированной части массива и перемещает его в конец отсортированной части. Процесс повторяется until весь массив не будет отсортирован.

```go
func Choice(arr []int) {
	fmt.Println("\n---Сортировка выбором---")

	size := len(arr)

	for i := 0; i < size; i++ {
		min_index := i

		for j := i + 1; j < size; j++ {
			if arr[j] < arr[min_index] {
				min_index = j
			}
		}

		arr[i], arr[min_index] = arr[min_index], arr[i]
	}

	fmt.Println("Отсортированный массив:", arr)
}
```

[Вернуться к оглавлению](#оглавление)

## ***Сортировка алгоритмом шелла***
<div align="center">
  <img alt="Foto 1" src="Image/image6.png" width="300" height="400"/>
</div>

---

Сортировка Шелла — это оптимизированная версия сортировки вставками, которая сортирует элементы на определённых расстояниях (интервалах), постепенно уменьшая интервал до одного. Алгоритм начинает с крупных интервалов, что позволяет элементам быстрее перемещаться в нужную позицию.

```go
func Shella(arr []int) {
	fmt.Println("\n---Сортировка алгоритмом Шелла---")

	size := len(arr)
	gap := size / 2

	for gap > 0 {
		for i := gap; i < size; i++ {
			per := arr[i]
			j := i

			for j >= gap && arr[j-gap] > per {
				arr[j] = arr[j-gap]
				j -= gap
			}
			arr[j] = per
		}
		gap /= 2
	}

	fmt.Println("Отсортированный массив:", arr)
}
```

[Вернуться к оглавлению](#оглавление)

## ***Гномья сортировка***
<div align="center">
  <img alt="Foto 1" src="Image/image7.jpeg" width="600" height="300"/>
</div>

---


[Вернуться к оглавлению](#оглавление)

## ***Заключение***

<div align="center"><b>Сравнение сортировок</b> </div>

|*Сортировка*|*Сложность*|*Память*|*Стабильность*|*n = 1000*|*n = 10000*|*n = 100000*|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|Пузырьковая|O(n²)|O(1)|✅|855700 ns|35649200 ns|10156168200 ns|
|Шейкерная|O(n²)|O(1)|✅|543300 ns|29440800 ns|7761250000 ns|
|Вставками|O(n²)|O(1)|✅|545800 ns|7160500 ns|802359200 ns|
|Выбором|O(n²)|O(1)|❌|520400 ns|31290600 ns|2408448800 ns|
|Шелла|O(n log²n)|O(1)|❌|0 ns|0 ns|15191700 ns|

---

Среди всех рассмотренных методов можно выделить четкое разделение на практические и учебные алгоритмы. Быстрая сортировка и сортировка Шелла демонстрируют наилучшую производительность и рекомендуются для реальных проектов с большими объемами данных. Эти алгоритмы обеспечивают оптимальное быстродействие за счет сложной организации вычислений.

Для образовательных целей и работы с небольшими наборами данных идеально подходят пузырьковая сортировка и сортировка вставками. Их главное преимущество — простота понимания и реализации, что делает их незаменимыми при изучении основ алгоритмизации.

Важным критерием выбора является требование к стабильности сортировки. Если необходимо сохранить относительный порядок равных элементов, следует выбирать среди стабильных алгоритмов: сортировку вставками, пузырьковую или шейкерную.

С точки зрения экономии памяти все рассмотренные алгоритмы, кроме быстрой сортировки, работают с постоянным потреблением дополнительной памяти, что делает их предпочтительными в системах с ограниченными ресурсами.

Таким образом, оптимальный выбор алгоритма сортировки зависит от конкретной задачи: объема данных, требований к скорости выполнения, доступных ресурсов памяти и необходимости сохранения порядка элементов.

[Вернуться к оглавлению](#оглавление)

[Вернуться на главную страницу](/README.md)

<div align="center">
  <img alt="Foto 1" src="Image/image8.png" width="600" height="400"/>
</div>

---

<div align="center"> Made with ❤️ by <b>l1m3ow</b> </div>