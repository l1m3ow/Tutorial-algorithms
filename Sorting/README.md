# ***Тема №3: Алгоритмы сортировок***
<div align="center">
  <img alt="Foto 1" src="Image/image1.png" width="600" height="400"/>
</div>

***Алгоритмы сортировки*** — это алгоритмы, которые упорядочивают элементы коллекции (массива, списка и т.д.) в определённом порядке, обычно по возрастанию.

# ***Оглавление***

1. [Пузырьковая сортировка](#пузырьковая-сортировка)
2. [Шейкерная сортировка](#шейкерная-сортировка)
3. [Сортировка вставками](#сортировка-вставками)
4. [Сортировка выбором](#сортировка-выбором)
5. [Сортировка алгоритмом шелла](#сортировка-алгоритмом-шелла)
6. [Гномья сортировка](#гномья-сортировка)
7. [Быстрая сортировка](#быстрая-сортировка)
8. [Заключение](#заключение)

## ***Для работы с кодом используйте этот шаблон + функция сортировки***

```go
package main

import (
	"fmt"
	"math/rand"
)

func main() {
	var size int
	fmt.Print("Введите размер массива: ")
	fmt.Scan(&size)

	arr := make([]int, size)
	for i := 0; i < size; i++ {
		arr[i] = rand.Intn(101)
	}

	Gnome(arr) //меняйте название сортировки и всё 
	// только для quickSort нужно 4 аргумента указать
	// step := 1 
	// quickSort(arr, 0, size, &step)
}
```

## ***Пузырьковая сортировка***
<div align="center">
  <img alt="Foto 2" src="Image/image2.png" width="700" height="350"/>
</div>

**Пузырьковая сортировка** — один из простейших алгоритмов сортировки. Суть алгоритма в том, что совершается несколько проходов по массиву. При каждом проходе попарно **сравниваются два соседних элемента.** Если они находятся в верном порядке, то ничего не происходит, в противном случае они меняются местами. В результате первого прохода **максимальный элемент окажется в конце, то есть всплывет словно пузырек.** Затем все повторяется до того момента пока весь массив не будет отсортирован.

```go
func Bubble(arr []int) {
	fmt.Println("\n---Пузырьковая сортировка---")
    fmt.Printf("Изначальный массив: %d\n", arr)

	size := len(arr)

	for j := 0; j < size-1; j++ {
		swap := false

		for k := 0; k < size-1-j; k++ {
			if arr[k] > arr[k+1] {
				arr[k], arr[k+1] = arr[k+1], arr[k]
				swap = true
			}
		}

		if !swap {
			break
		}
		
		fmt.Printf("\nПосле прохода номер %d по массиву\nMaссив : %d \n", j+1, arr)
	}
}
```

*Что происходит*
<div align="center">
  <img alt="Gif 1" src="Image/gif1.gif" width="700" height="300"/>
</div>

*Пример работы кода*

```
Введите размер массива:

---Пузырьковая сортировка---
Изначальный массив: [62 18 2 63 88 54 41 38 59 71]

После прохода номер 1 по массиву
Maссив : [18 2 62 63 54 41 38 59 71 88] 

После прохода номер 2 по массиву
Maссив : [2 18 62 54 41 38 59 63 71 88] 

После прохода номер 3 по массиву
Maссив : [2 18 54 41 38 59 62 63 71 88] 

После прохода номер 4 по массиву
Maссив : [2 18 41 38 54 59 62 63 71 88] 

После прохода номер 5 по массиву
Maссив : [2 18 38 41 54 59 62 63 71 88] 
```

[Вернуться к оглавлению](#оглавление)

## ***Шейкерная сортировка***
<div align="center">
  <img alt="Foto 3" src="Image/image3.png" width="700" height="350"/>
</div>

**Шейкерная сортировка (сортировка перемешиванием)** — это алгоритм, при котором массив обрабатывается за несколько проходов в двух направлениях. На каждом этапе выполняются **два последовательных прохода: сначала слева направо, затем справа налево.** При проходе **сравниваются попарно соседние элементы,** и если они находятся в неверном порядке, они **меняются местами.** В результате прохода слева направо **наибольший из неотсортированных элементов "всплывает" в конец** массива, а при проходе справа налево **наименьший элемент "оседает" в начало.** Таким образом, **отсортированные элементы накапливаются с обоих концов** массива, что в среднем ускоряет процесс по сравнению с пузырьковой сортировкой.

```go
func Shaker(arr []int) {
	fmt.Println("\n---Шейкерная сортировка---")
	fmt.Printf("Изначальный массив: %d\n", arr)

	size := len(arr)
	left := 0
	right := size - 1
	step := 1
	k := 1

	for left < right {
		for i := left; i < right; i++ {
			if arr[i] > arr[i+1] {
				arr[i], arr[i+1] = arr[i+1], arr[i]
			}
		}

		right--
		step++

		for i := right; i > left; i-- {
			if arr[i] < arr[i-1] {
				arr[i], arr[i-1] = arr[i-1], arr[i]
			}
		}

		left++
		step++

		fmt.Printf("\nПосле прохода номер %d по массиву\nMaссив : %d \n", k, arr)
		k++
	}
}
```

*Пример работы кода*

```
Введите размер массива: 10

---Шейкерная сортировка---
Изначальный массив: [75 0 73 93 15 39 77 64 50 44]

После прохода номер 1 по массиву
Maссив : [0 15 73 75 39 44 77 64 50 93] 

После прохода номер 2 по массиву
Maссив : [0 15 39 73 44 50 75 64 77 93] 

После прохода номер 3 по массиву
Maссив : [0 15 39 44 50 64 73 75 77 93] 

После прохода номер 4 по массиву
Maссив : [0 15 39 44 50 64 73 75 77 93] 

После прохода номер 5 по массиву
Maссив : [0 15 39 44 50 64 73 75 77 93]
```

[Вернуться к оглавлению](#оглавление)

## ***Сортировка вставками***
<div align="center">
  <img alt="Foto 4" src="Image/image4.png" width="700" height="350"/>
</div>

**Сортировка вставками** — алгоритм, при котором массив **делится на две области**: упорядоченную и неупорядоченную. На каждом шаге **первый элемент из неотсортированной области помещается в правильную позицию** внутри упорядоченной. Для этого он **последовательно сравнивается с элементами** отсортированной части, пока не займёт своё место. Таким образом, **упорядоченная часть постепенно расширяется**, пока не будет охвачен весь массив.

```go
func Inserts(arr []int) {
	fmt.Println("\n---Сортировка вставками---")
	fmt.Printf("Изначальный массив: %d\n", arr)

	size := len(arr)

	for i := 1; i < size; i++ {
		per := arr[i]
		j := i - 1
		for j >= 0 && arr[j] > per {
			arr[j+1] = arr[j]
			j--
		}
		arr[j+1] = per

		fmt.Printf("\nПосле прохода номер %d по массиву\nMaссив : %d \n", i, arr)
	}
}
```

*Что происходит*
<div align="center">
  <img alt="Gif 2" src="Image/gif2.gif" width="700" height="300"/>
</div>

*Пример работы кода*

```
Введите размер массива: 10

---Сортировка вставками---
Изначальный массив: [80 77 94 26 44 92 55 22 62 7]

После прохода номер 1 по массиву
Maссив : [77 80 94 26 44 92 55 22 62 7]

После прохода номер 2 по массиву
Maссив : [77 80 94 26 44 92 55 22 62 7]

После прохода номер 3 по массиву
Maссив : [26 77 80 94 44 92 55 22 62 7]

После прохода номер 4 по массиву
Maссив : [26 44 77 80 94 92 55 22 62 7]

После прохода номер 5 по массиву
Maссив : [26 44 77 80 92 94 55 22 62 7]

После прохода номер 6 по массиву
Maссив : [26 44 55 77 80 92 94 22 62 7]

После прохода номер 7 по массиву
Maссив : [22 26 44 55 77 80 92 94 62 7]

После прохода номер 8 по массиву
Maссив : [22 26 44 55 62 77 80 92 94 7]

После прохода номер 9 по массиву
Maссив : [7 22 26 44 55 62 77 80 92 94]
```

[Вернуться к оглавлению](#оглавление)

## ***Сортировка выбором***
<div align="center">
  <img alt="Foto 5" src="Image/image5.png" width="600" height="400"/>
</div>

**Сортировка выбором** — алгоритм, в котором **массив последовательно делится на две части**: отсортированную и неотсортированную. На каждом проходе **осуществляется поиск минимального элемента** в неупорядоченной части. Найденный **минимум меняется местами с первым элементом** неотсортированной области. После этого **граница отсортированной части сдвигается**, а процесс повторяется для оставшихся элементов. Алгоритм продолжает работу до полного упорядочивания массива.

```go
func Choice(arr []int) {
	fmt.Println("\n---Сортировка выбором---")
	fmt.Printf("Изначальный массив: %d\n", arr)

	size := len(arr)

	for i := 0; i < size; i++ {
		min_index := i

		for j := i + 1; j < size; j++ {
			if arr[j] < arr[min_index] {
				min_index = j
			}
		}

		arr[i], arr[min_index] = arr[min_index], arr[i]

		fmt.Printf("\nПосле прохода номер %d по массиву\nMaссив : %d \n", i+1, arr)
	}
}
```

*Что происходит*
<div align="center">
  <img alt="Gif 3" src="Image/gif3.gif" width="700" height="300"/>
</div>

*Пример работы кода*

```
Введите размер массива: 10

---Сортировка выбором---
Изначальный массив: [98 4 33 52 93 90 85 48 57 41]

После прохода номер 1 по массиву
Maссив : [4 98 33 52 93 90 85 48 57 41]

После прохода номер 2 по массиву
Maссив : [4 33 98 52 93 90 85 48 57 41]

После прохода номер 3 по массиву
Maссив : [4 33 41 52 93 90 85 48 57 98]

После прохода номер 4 по массиву
Maссив : [4 33 41 48 93 90 85 52 57 98]

После прохода номер 5 по массиву
Maссив : [4 33 41 48 52 90 85 93 57 98]

После прохода номер 6 по массиву
Maссив : [4 33 41 48 52 57 85 93 90 98]

После прохода номер 7 по массиву
Maссив : [4 33 41 48 52 57 85 93 90 98]

После прохода номер 8 по массиву
Maссив : [4 33 41 48 52 57 85 90 93 98]

После прохода номер 9 по массиву
Maссив : [4 33 41 48 52 57 85 90 93 98]

После прохода номер 10 по массиву
Maссив : [4 33 41 48 52 57 85 90 93 98]
```

[Вернуться к оглавлению](#оглавление)

## ***Сортировка алгоритмом шелла***
<div align="center">
  <img alt="Foto 1" src="Image/image6.png" width="300" height="400"/>
</div>

**Сортировка Шелла** — это алгоритм, при котором массив обрабатывается за несколько проходов с использованием определённых **интервалов (шагов)** между сравниваемыми элементами. На каждом этапе **массив сортируется вставками, но не между соседними элементами, а между элементами, отстоящими друг от друга на текущем интервале.** Алгоритм начинается с **крупных интервалов,** что позволяет элементам **быстро переместиться в нужном направлении,** преодолевая большие расстояния. После каждого прохода **интервал постепенно уменьшается,** пока не станет равным единице, что соответствует окончательной **обычной сортировке вставками.** Таким образом, на ранних этапах **эффективно ликвидируется беспорядок** в массиве, что в итоге повышает общую скорость сортировки.

```go
func Shella(arr []int) {
	fmt.Println("\n---Сортировка алгоритмом Шелла---")
	fmt.Printf("Изначальный массив: %d\n", arr)

	size := len(arr)
	gap := size / 2
	k := 1

	for gap > 0 {
		for i := gap; i < size; i++ {
			per := arr[i]
			j := i

			for j >= gap && arr[j-gap] > per {
				arr[j] = arr[j-gap]
				j -= gap
			}
			arr[j] = per
		}
		gap /= 2

		fmt.Printf("\nПосле прохода номер %d по массиву\nMaссив : %d \n", k, arr)
		k++
	}
}
```

*Пример работы кода*

```
Введите размер массива: 10

---Сортировка алгоритмом Шелла---
Изначальный массив: [57 46 68 14 17 87 98 24 0 63]

После прохода номер 1 по массиву
Maссив : [57 46 24 0 17 87 98 68 14 63] 

После прохода номер 2 по массиву
Maссив : [14 0 17 46 24 63 57 68 98 87] 

После прохода номер 3 по массиву
Maссив : [0 14 17 24 46 57 63 68 87 98] 
```

[Вернуться к оглавлению](#оглавление)

## ***Гномья сортировка***
<div align="center">
  <img alt="Foto 1" src="Image/image7.jpeg" width="600" height="300"/>
</div>

**Гномья сортировка** — алгоритм, при котором массив обрабатывается за один проход с использованием **всего одного цикла.** На каждом шаге **сравниваются два соседних элемента** — текущий и предыдущий. Если они находятся в верном порядке, алгоритм **"движется вперед"** к следующему элементу. Если порядок нарушен, элементы **меняются местами,** и алгоритм **"отступает на шаг назад."** Такой подход напоминает движение садового гнома, который проверяет и упорядочивает горшки с цветами, продвигаясь вперед при правильном порядке и возвращаясь назад после каждого обмена. Таким образом, массив **постепенно упорядочивается слева направо,** пока все элементы не будут отсортированы.

```go
func Gnome(arr []int) {
	fmt.Println("\n---Гномья сортировка---")
	fmt.Printf("Изначальный массив: %d\n", arr)

	i := 1
	k := 1

	for i < len(arr) {
		if i > 0 && arr[i-1] > arr[i] {
			arr[i], arr[i-1] = arr[i-1], arr[i]
			i--
		} else {
			i++
		}
		fmt.Printf("\nПосле шага номер %d по массиву\nMaссив : %d \n", k, arr)
		k++

	}
}
```

*Пример работы кода*

```
Введите размер массива: 6

---Гномья сортировка---
Изначальный массив: [7 59 22 61 25 94]

После шага номер 1 по массиву
Maссив : [7 59 22 61 25 94]

После шага номер 2 по массиву
Maссив : [7 22 59 61 25 94]

После шага номер 3 по массиву
Maссив : [7 22 59 61 25 94]

После шага номер 4 по массиву
Maссив : [7 22 59 61 25 94]

После шага номер 5 по массиву
Maссив : [7 22 59 61 25 94]

После шага номер 6 по массиву
Maссив : [7 22 59 25 61 94]

После шага номер 7 по массиву
Maссив : [7 22 25 59 61 94]

После шага номер 8 по массиву
Maссив : [7 22 25 59 61 94]

После шага номер 9 по массиву
Maссив : [7 22 25 59 61 94]

После шага номер 10 по массиву
Maссив : [7 22 25 59 61 94]

После шага номер 11 по массиву
Maссив : [7 22 25 59 61 94]
```

[Вернуться к оглавлению](#оглавление)

## ***Быстрая сортировка***
<div align="center">
  <img alt="Foto 1" src="Image/image7.png" width="400" height="300"/>
</div>

**Быстрая сортировка** — алгоритм, который работает по принципу "разделяй и властвуй" через рекурсию. В отличие от пошагового прохода по массиву, он дробит задачу на более мелкие части.

Вот как это работает:

1. **Выбор опорного элемента** — из массива выбирается произвольный элемент (например, средний или случайный), который становится "опорой".

2. **Разделение массива** — все элементы массива перераспределяются так, чтобы:
   * Слева оказались элементы **меньше** опорного
   * Справа — элементы **больше или равные** опорному
   
   После этого разделения опорный элемент оказывается на своём окончательном месте в отсортированном массиве.

3. **Рекурсивное применение** — алгоритм применяется рекурсивно к левой и правой частям массива (к элементам до опоры и после неё).

4. **Базовый случай** — когда часть массива состоит из одного элемента или пуста, она считается отсортированной по умолчанию.

Таким образом, массив не просто последовательно упорядочивается, а **быстро дробится на упорядоченные сегменты**, которые постепенно формируют полностью отсортированный массив. Каждое разделение ставит опорный элемент на правильную позицию, что делает алгоритм очень эффективным.

```go
func quickSort(arr []int, low, high int, step *int) {
	if low < high {
		fmt.Printf("\nШаг %d: Сортируем %v\n", *step, arr[low:high+1])
		*step++

		pivotIndex := partition(arr, low, high)

		fmt.Printf("После разделения: %v (опора %d на позиции %d)\n", arr[low:high+1], arr[pivotIndex], pivotIndex)

		fmt.Printf("Рекурсия: левая часть %v\n", arr[low:pivotIndex])
		quickSort(arr, low, pivotIndex-1, step)

		fmt.Printf("Рекурсия: правая часть %v\n", arr[pivotIndex+1:high+1])
		quickSort(arr, pivotIndex+1, high, step)
	}
}

func partition(arr []int, low, high int) int {
	mid := (low + high) / 2
	pivot := arr[mid]

	arr[mid], arr[high] = arr[high], arr[mid]
	i := low

	for j := low; j < high; j++ {
		if arr[j] <= pivot {
			arr[i], arr[j] = arr[j], arr[i]
			i++
		}
	}
	arr[i], arr[high] = arr[high], arr[i]
	return i
}
```

*Что происходит*

<div align="center">
  <img alt="Gif 4" src="Image/gif4.gif" width="700" height="300"/>
</div>

*Пример работы кода*

```
Введите размер массива: 10

---Быстрая сортировка---
Изначальный массив: [57 81 9 17 20 90 68 28 76 56]

Шаг 1: Сортируем [57 81 9 17 20 90 68 28 76 56]
После разделения: [9 17 20 81 56 90 68 28 76 57] (опора 20 на позиции 2)
Рекурсия: левая часть [9 17]

Шаг 2: Сортируем [9 17]
После разделения: [9 17] (опора 9 на позиции 0)
Рекурсия: левая часть []
Рекурсия: правая часть [17]
Рекурсия: правая часть [81 56 90 68 28 76 57]

Шаг 3: Сортируем [81 56 90 68 28 76 57]
После разделения: [56 57 28 68 90 76 81] (опора 68 на позиции 6)
Рекурсия: левая часть [56 57 28]

Шаг 4: Сортируем [56 57 28]
После разделения: [56 28 57] (опора 57 на позиции 5)
Рекурсия: левая часть [56 28]

Шаг 5: Сортируем [56 28]
После разделения: [28 56] (опора 56 на позиции 4)
Рекурсия: левая часть [28]
Рекурсия: правая часть []
Рекурсия: правая часть []
Рекурсия: правая часть [90 76 81]

Шаг 6: Сортируем [90 76 81]
После разделения: [76 81 90] (опора 76 на позиции 7)
Рекурсия: левая часть []
Рекурсия: правая часть [81 90]

Шаг 7: Сортируем [81 90]
После разделения: [81 90] (опора 81 на позиции 8)
Рекурсия: левая часть []
Рекурсия: правая часть [90]
```

[Вернуться к оглавлению](#оглавление)

## ***Заключение***

<div align="center"><b>Сравнение сортировок</b> </div>

|*Сортировка*|*Сложность*|*Память*|*Стабильность*|*n = 1000*|*n = 10000*|*n = 100000*|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|Пузырьковая|O(n²)|O(1)|✅|855700 ns|35649200 ns|10156168200 ns|
|Шейкерная|O(n²)|O(1)|✅|543300 ns|29440800 ns|7761250000 ns|
|Вставками|O(n²)|O(1)|✅|545800 ns|7160500 ns|802359200 ns|
|Гномья|O(n²)|O(1)|✅|589200 ns|66874500 ns|5376532900 ns|
|Выбором|O(n²)|O(1)|❌|520400 ns|31290600 ns|2408448800 ns|
|Шелла|O(n log²n)|O(1)|❌|0 ns|0 ns|15191700 ns|
|Быстрая|O(n log n)|O(log n)|❌|0 ns|0 ns|15856100 ns|

**Пузырьковая** - последовательное сравнение и обмен соседних элементов, "всплытие" максимумов

**Шейкерная** - двунаправленная версия пузырьковой сортировки с проходами слева-направо и справа-налево 

**Вставками** - построение отсортированной части массива путем вставки элементов в нужную позицию 

**Выбором** - поиск минимального элемента в неотсортированной части и обмен с текущей позицией 

**Шелла** - сортировка вставками с предварительной групповой сортировкой на больших расстояниях 

**Гномья** - алгоритм с одной петлей, попарно обменивающий элементы при движении вперед-назад  

**Быстрая** - стратегия "разделяй и властвуй" с выбором опорного элемента и рекурсивным разделением

[Вернуться к оглавлению](#оглавление)

[Вернуться на главную страницу](/README.md)

<div align="center">
  <img alt="Foto 1" src="Image/image8.png" width="600" height="400"/>
</div>

---

<div align="center"> Made with ❤️ by <b>l1m3ow</b> </div>