# ***Тема №3: Алгоритмы сортировок***
<div align="center">
  <img alt="Foto 1" src="Image/image1.png" width="600" height="400"/>
</div>

# ***Оглавление***

1. [Пузырьковая сортировка](#пузырьковая-сортировка)
2. [Шейкерная сортировка](#шейкерная-сортировка)
3. [Сортировка вставками](#сортировка-вставками)
4. [Сортировка выбором](#сортировка-выбором)
5. [Сортировка алгоритмом шелла](#сортировка-алгоритмом-шелла)
6. [Гномья сортировка](#гномья-сортировка)
7. [Заключение](#заключение)

## ***Пузырьковая сортировка***
<div align="center">
  <img alt="Foto 2" src="Image/image2.png" width="700" height="350"/>
</div>

**Пузырьковая сортировка** — один из простейших алгоритмов сортировки. Суть алгоритма в том, что совершается несколько проходов по массиву. При каждом проходе попарно **сравниваются два соседних элемента.** Если они находятся в верном порядке, то ничего не происходит, в противном случае они меняются местами. В результате первого прохода **максимальный элемент окажется в конце, то есть всплывет словно пузырек.** Затем все повторяется до того момента пока весь массив не будет отсортирован.

```go
func Bubble(arr []int) {
	fmt.Println("\n---Пузырьковая сортировка---")
    fmt.Printf("Изначальный массив: %d\n", arr)

	size := len(arr)

	for j := 0; j < size-1; j++ {
		swap := false

		for k := 0; k < size-1-j; k++ {
			if arr[k] > arr[k+1] {
				arr[k], arr[k+1] = arr[k+1], arr[k]
				swap = true
			}
		}

		if !swap {
			break
		}
		fmt.Printf("\nПосле прохода номер %d по массиву\nMaссив : %d \n", j+1, arr)
	}
}
```

*Что происходит*
<div align="center">
  <img alt="Gif 1" src="Image/gif1.gif" width="700" height="300"/>
</div>

*Пример работы кода*

```
Введите размер массива:

---Пузырьковая сортировка---
Изначальный массив: [62 18 2 63 88 54 41 38 59 71]

После прохода номер 1 по массиву
Maссив : [18 2 62 63 54 41 38 59 71 88] 

После прохода номер 2 по массиву
Maссив : [2 18 62 54 41 38 59 63 71 88] 

После прохода номер 3 по массиву
Maссив : [2 18 54 41 38 59 62 63 71 88] 

После прохода номер 4 по массиву
Maссив : [2 18 41 38 54 59 62 63 71 88] 

После прохода номер 5 по массиву
Maссив : [2 18 38 41 54 59 62 63 71 88] 
```

[Вернуться к оглавлению](#оглавление)

## ***Шейкерная сортировка***
<div align="center">
  <img alt="Foto 3" src="Image/image3.png" width="700" height="350"/>
</div>

Шейкерная сортировка (сортировка перемешиванием) — это улучшенная версия пузырьковой сортировки, которая проходит массив в обоих направлениях: слева направо и справа налево. На каждом проходе наибольшие элементы "всплывают" в конец, а наименьшие "оседают" в начале, что ускоряет процесс сортировки.

```go
func Shaker(arr []int) {
	fmt.Println("\n---Шейкерная сортировка---")

	size := len(arr)
	left := 0
	right := size - 1
	step := 1

	for left < right {
		for i := left; i < right; i++ {
			if arr[i] > arr[i+1] {
				arr[i], arr[i+1] = arr[i+1], arr[i]
			}
		}

		right--
		step++

		for i := right; i > left; i-- {
			if arr[i] < arr[i-1] {
				arr[i], arr[i-1] = arr[i-1], arr[i]
			}
		}

		left++
		step++
	}

	fmt.Println("Отсортированный массив:", arr)
}
```

[Вернуться к оглавлению](#оглавление)

## ***Сортировка вставками***
<div align="center">
  <img alt="Foto 4" src="Image/image4.png" width="700" height="350"/>
</div>

**Сортировка вставками** — алгоритм, при котором массив **делится на две области**: упорядоченную и неупорядоченную. На каждом шаге **первый элемент из неотсортированной области помещается в правильную позицию** внутри упорядоченной. Для этого он **последовательно сравнивается с элементами** отсортированной части, пока не займёт своё место. Таким образом, **упорядоченная часть постепенно расширяется**, пока не будет охвачен весь массив.

```go
func Inserts(arr []int) {
	fmt.Println("\n---Сортировка вставками---")
	fmt.Printf("Изначальный массив: %d\n", arr)

	size := len(arr)

	for i := 1; i < size; i++ {
		per := arr[i]
		j := i - 1
		for j >= 0 && arr[j] > per {
			arr[j+1] = arr[j]
			j--
		}
		arr[j+1] = per
		fmt.Printf("\nПосле прохода номер %d по массиву\nMaссив : %d \n", i, arr)
	}
}
```

*Что происходит*
<div align="center">
  <img alt="Gif 2" src="Image/gif2.gif" width="700" height="300"/>
</div>

*Пример работы кода*

```
Введите размер массива: 10

---Сортировка вставками---
Изначальный массив: [80 77 94 26 44 92 55 22 62 7]

После прохода номер 1 по массиву
Maссив : [77 80 94 26 44 92 55 22 62 7]

После прохода номер 2 по массиву
Maссив : [77 80 94 26 44 92 55 22 62 7]

После прохода номер 3 по массиву
Maссив : [26 77 80 94 44 92 55 22 62 7]

После прохода номер 4 по массиву
Maссив : [26 44 77 80 94 92 55 22 62 7]

После прохода номер 5 по массиву
Maссив : [26 44 77 80 92 94 55 22 62 7]

После прохода номер 6 по массиву
Maссив : [26 44 55 77 80 92 94 22 62 7]

После прохода номер 7 по массиву
Maссив : [22 26 44 55 77 80 92 94 62 7]

После прохода номер 8 по массиву
Maссив : [22 26 44 55 62 77 80 92 94 7]

После прохода номер 9 по массиву
Maссив : [7 22 26 44 55 62 77 80 92 94]
```

[Вернуться к оглавлению](#оглавление)

## ***Сортировка выбором***
<div align="center">
  <img alt="Foto 5" src="Image/image5.png" width="600" height="400"/>
</div>

**Сортировка выбором** — алгоритм, в котором **массив последовательно делится на две части**: отсортированную и неотсортированную. На каждом проходе **осуществляется поиск минимального элемента** в неупорядоченной части. Найденный **минимум меняется местами с первым элементом** неотсортированной области. После этого **граница отсортированной части сдвигается**, а процесс повторяется для оставшихся элементов. Алгоритм продолжает работу до полного упорядочивания массива.

```go
func Choice(arr []int) {
	fmt.Println("\n---Сортировка выбором---")

	size := len(arr)

	for i := 0; i < size; i++ {
		min_index := i

		for j := i + 1; j < size; j++ {
			if arr[j] < arr[min_index] {
				min_index = j
			}
		}

		arr[i], arr[min_index] = arr[min_index], arr[i]
	}

	fmt.Println("Отсортированный массив:", arr)
}
```

*Что происходит*
<div align="center">
  <img alt="Gif 3" src="Image/gif3.gif" width="700" height="300"/>
</div>

[Вернуться к оглавлению](#оглавление)

## ***Сортировка алгоритмом шелла***
<div align="center">
  <img alt="Foto 1" src="Image/image6.png" width="300" height="400"/>
</div>

Сортировка Шелла — это оптимизированная версия сортировки вставками, которая сортирует элементы на определённых расстояниях (интервалах), постепенно уменьшая интервал до одного. Алгоритм начинает с крупных интервалов, что позволяет элементам быстрее перемещаться в нужную позицию.

```go
func Shella(arr []int) {
	fmt.Println("\n---Сортировка алгоритмом Шелла---")

	size := len(arr)
	gap := size / 2

	for gap > 0 {
		for i := gap; i < size; i++ {
			per := arr[i]
			j := i

			for j >= gap && arr[j-gap] > per {
				arr[j] = arr[j-gap]
				j -= gap
			}
			arr[j] = per
		}
		gap /= 2
	}

	fmt.Println("Отсортированный массив:", arr)
}
```

[Вернуться к оглавлению](#оглавление)

## ***Гномья сортировка***
<div align="center">
  <img alt="Foto 1" src="Image/image7.jpeg" width="600" height="300"/>
</div>

[Вернуться к оглавлению](#оглавление)

## ***Заключение***

<div align="center"><b>Сравнение сортировок</b> </div>

|*Сортировка*|*Сложность*|*Память*|*Стабильность*|*n = 1000*|*n = 10000*|*n = 100000*|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|Пузырьковая|O(n²)|O(1)|✅|855700 ns|35649200 ns|10156168200 ns|
|Шейкерная|O(n²)|O(1)|✅|543300 ns|29440800 ns|7761250000 ns|
|Вставками|O(n²)|O(1)|✅|545800 ns|7160500 ns|802359200 ns|
|Выбором|O(n²)|O(1)|❌|520400 ns|31290600 ns|2408448800 ns|
|Шелла|O(n log²n)|O(1)|❌|0 ns|0 ns|15191700 ns|

---

Среди всех рассмотренных методов можно выделить четкое разделение на практические и учебные алгоритмы. Быстрая сортировка и сортировка Шелла демонстрируют наилучшую производительность и рекомендуются для реальных проектов с большими объемами данных. Эти алгоритмы обеспечивают оптимальное быстродействие за счет сложной организации вычислений.

Для образовательных целей и работы с небольшими наборами данных идеально подходят пузырьковая сортировка и сортировка вставками. Их главное преимущество — простота понимания и реализации, что делает их незаменимыми при изучении основ алгоритмизации.

Важным критерием выбора является требование к стабильности сортировки. Если необходимо сохранить относительный порядок равных элементов, следует выбирать среди стабильных алгоритмов: сортировку вставками, пузырьковую или шейкерную.

С точки зрения экономии памяти все рассмотренные алгоритмы, кроме быстрой сортировки, работают с постоянным потреблением дополнительной памяти, что делает их предпочтительными в системах с ограниченными ресурсами.

Таким образом, оптимальный выбор алгоритма сортировки зависит от конкретной задачи: объема данных, требований к скорости выполнения, доступных ресурсов памяти и необходимости сохранения порядка элементов.

[Вернуться к оглавлению](#оглавление)

[Вернуться на главную страницу](/README.md)

<div align="center">
  <img alt="Foto 1" src="Image/image8.png" width="600" height="400"/>
</div>

---

<div align="center"> Made with ❤️ by <b>l1m3ow</b> </div>