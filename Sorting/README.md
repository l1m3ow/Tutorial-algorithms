# ***Тема №3: Алгоритмы сортировок***
<div align="center">
  <img alt="Foto 1" src="Image/image1.png" width="600" height="400"/>
</div>

# ***Оглавление***

1. [Пузырьковая сортировка](#пузырьковая-сортировка)
2. [Шейкерная сортировка](#шейкерная-сортировка)
3. [Сортировка вставками](#сортировка-вставками)
4. [Сортировка выбором](#сортировка-выбором)
5. [Сортировка алгоритмом шелла](#сортировка-алгоритмом-шелла)
6. [Гномья сортировка](#гномья-сортировка)
7. [Быстрая сортировка](#быстрая-сортировка)
8. [Заключение](#заключение)

## ***Пузырьковая сортировка***
<div align="center">
  <img alt="Foto 2" src="Image/image2.png" width="700" height="350"/>
</div>

**Пузырьковая сортировка** — один из простейших алгоритмов сортировки. Суть алгоритма в том, что совершается несколько проходов по массиву. При каждом проходе попарно **сравниваются два соседних элемента.** Если они находятся в верном порядке, то ничего не происходит, в противном случае они меняются местами. В результате первого прохода **максимальный элемент окажется в конце, то есть всплывет словно пузырек.** Затем все повторяется до того момента пока весь массив не будет отсортирован.

```go
func Bubble(arr []int) {
	fmt.Println("\n---Пузырьковая сортировка---")
    fmt.Printf("Изначальный массив: %d\n", arr)

	size := len(arr)

	for j := 0; j < size-1; j++ {
		swap := false

		for k := 0; k < size-1-j; k++ {
			if arr[k] > arr[k+1] {
				arr[k], arr[k+1] = arr[k+1], arr[k]
				swap = true
			}
		}

		if !swap {
			break
		}
		
		fmt.Printf("\nПосле прохода номер %d по массиву\nMaссив : %d \n", j+1, arr)
	}
}
```

*Что происходит*
<div align="center">
  <img alt="Gif 1" src="Image/gif1.gif" width="700" height="300"/>
</div>

*Пример работы кода*

```
Введите размер массива:

---Пузырьковая сортировка---
Изначальный массив: [62 18 2 63 88 54 41 38 59 71]

После прохода номер 1 по массиву
Maссив : [18 2 62 63 54 41 38 59 71 88] 

После прохода номер 2 по массиву
Maссив : [2 18 62 54 41 38 59 63 71 88] 

После прохода номер 3 по массиву
Maссив : [2 18 54 41 38 59 62 63 71 88] 

После прохода номер 4 по массиву
Maссив : [2 18 41 38 54 59 62 63 71 88] 

После прохода номер 5 по массиву
Maссив : [2 18 38 41 54 59 62 63 71 88] 
```

[Вернуться к оглавлению](#оглавление)

## ***Шейкерная сортировка***
<div align="center">
  <img alt="Foto 3" src="Image/image3.png" width="700" height="350"/>
</div>

**Шейкерная сортировка (сортировка перемешиванием)** — это алгоритм, при котором массив обрабатывается за несколько проходов в двух направлениях. На каждом этапе выполняются **два последовательных прохода: сначала слева направо, затем справа налево.** При проходе **сравниваются попарно соседние элементы,** и если они находятся в неверном порядке, они **меняются местами.** В результате прохода слева направо **наибольший из неотсортированных элементов "всплывает" в конец** массива, а при проходе справа налево **наименьший элемент "оседает" в начало.** Таким образом, **отсортированные элементы накапливаются с обоих концов** массива, что в среднем ускоряет процесс по сравнению с пузырьковой сортировкой.

```go
func Shaker(arr []int) {
	fmt.Println("\n---Шейкерная сортировка---")
	fmt.Printf("Изначальный массив: %d\n", arr)

	size := len(arr)
	left := 0
	right := size - 1
	step := 1
	k := 1

	for left < right {
		for i := left; i < right; i++ {
			if arr[i] > arr[i+1] {
				arr[i], arr[i+1] = arr[i+1], arr[i]
			}
		}

		right--
		step++

		for i := right; i > left; i-- {
			if arr[i] < arr[i-1] {
				arr[i], arr[i-1] = arr[i-1], arr[i]
			}
		}

		left++
		step++

		fmt.Printf("\nПосле прохода номер %d по массиву\nMaссив : %d \n", k, arr)
		k++
	}
}
```

*Пример работы кода*

```
Введите размер массива: 10

---Шейкерная сортировка---
Изначальный массив: [75 0 73 93 15 39 77 64 50 44]

После прохода номер 1 по массиву
Maссив : [0 15 73 75 39 44 77 64 50 93] 

После прохода номер 2 по массиву
Maссив : [0 15 39 73 44 50 75 64 77 93] 

После прохода номер 3 по массиву
Maссив : [0 15 39 44 50 64 73 75 77 93] 

После прохода номер 4 по массиву
Maссив : [0 15 39 44 50 64 73 75 77 93] 

После прохода номер 5 по массиву
Maссив : [0 15 39 44 50 64 73 75 77 93]
```

[Вернуться к оглавлению](#оглавление)

## ***Сортировка вставками***
<div align="center">
  <img alt="Foto 4" src="Image/image4.png" width="700" height="350"/>
</div>

**Сортировка вставками** — алгоритм, при котором массив **делится на две области**: упорядоченную и неупорядоченную. На каждом шаге **первый элемент из неотсортированной области помещается в правильную позицию** внутри упорядоченной. Для этого он **последовательно сравнивается с элементами** отсортированной части, пока не займёт своё место. Таким образом, **упорядоченная часть постепенно расширяется**, пока не будет охвачен весь массив.

```go
func Inserts(arr []int) {
	fmt.Println("\n---Сортировка вставками---")
	fmt.Printf("Изначальный массив: %d\n", arr)

	size := len(arr)

	for i := 1; i < size; i++ {
		per := arr[i]
		j := i - 1
		for j >= 0 && arr[j] > per {
			arr[j+1] = arr[j]
			j--
		}
		arr[j+1] = per

		fmt.Printf("\nПосле прохода номер %d по массиву\nMaссив : %d \n", i, arr)
	}
}
```

*Что происходит*
<div align="center">
  <img alt="Gif 2" src="Image/gif2.gif" width="700" height="300"/>
</div>

*Пример работы кода*

```
Введите размер массива: 10

---Сортировка вставками---
Изначальный массив: [80 77 94 26 44 92 55 22 62 7]

После прохода номер 1 по массиву
Maссив : [77 80 94 26 44 92 55 22 62 7]

После прохода номер 2 по массиву
Maссив : [77 80 94 26 44 92 55 22 62 7]

После прохода номер 3 по массиву
Maссив : [26 77 80 94 44 92 55 22 62 7]

После прохода номер 4 по массиву
Maссив : [26 44 77 80 94 92 55 22 62 7]

После прохода номер 5 по массиву
Maссив : [26 44 77 80 92 94 55 22 62 7]

После прохода номер 6 по массиву
Maссив : [26 44 55 77 80 92 94 22 62 7]

После прохода номер 7 по массиву
Maссив : [22 26 44 55 77 80 92 94 62 7]

После прохода номер 8 по массиву
Maссив : [22 26 44 55 62 77 80 92 94 7]

После прохода номер 9 по массиву
Maссив : [7 22 26 44 55 62 77 80 92 94]
```

[Вернуться к оглавлению](#оглавление)

## ***Сортировка выбором***
<div align="center">
  <img alt="Foto 5" src="Image/image5.png" width="600" height="400"/>
</div>

**Сортировка выбором** — алгоритм, в котором **массив последовательно делится на две части**: отсортированную и неотсортированную. На каждом проходе **осуществляется поиск минимального элемента** в неупорядоченной части. Найденный **минимум меняется местами с первым элементом** неотсортированной области. После этого **граница отсортированной части сдвигается**, а процесс повторяется для оставшихся элементов. Алгоритм продолжает работу до полного упорядочивания массива.

```go
func Choice(arr []int) {
	fmt.Println("\n---Сортировка выбором---")
	fmt.Printf("Изначальный массив: %d\n", arr)

	size := len(arr)

	for i := 0; i < size; i++ {
		min_index := i

		for j := i + 1; j < size; j++ {
			if arr[j] < arr[min_index] {
				min_index = j
			}
		}

		arr[i], arr[min_index] = arr[min_index], arr[i]

		fmt.Printf("\nПосле прохода номер %d по массиву\nMaссив : %d \n", i+1, arr)
	}
}
```

*Что происходит*
<div align="center">
  <img alt="Gif 3" src="Image/gif3.gif" width="700" height="300"/>
</div>

*Пример работы кода*

```
Введите размер массива: 10

---Сортировка выбором---
Изначальный массив: [98 4 33 52 93 90 85 48 57 41]

После прохода номер 1 по массиву
Maссив : [4 98 33 52 93 90 85 48 57 41]

После прохода номер 2 по массиву
Maссив : [4 33 98 52 93 90 85 48 57 41]

После прохода номер 3 по массиву
Maссив : [4 33 41 52 93 90 85 48 57 98]

После прохода номер 4 по массиву
Maссив : [4 33 41 48 93 90 85 52 57 98]

После прохода номер 5 по массиву
Maссив : [4 33 41 48 52 90 85 93 57 98]

После прохода номер 6 по массиву
Maссив : [4 33 41 48 52 57 85 93 90 98]

После прохода номер 7 по массиву
Maссив : [4 33 41 48 52 57 85 93 90 98]

После прохода номер 8 по массиву
Maссив : [4 33 41 48 52 57 85 90 93 98]

После прохода номер 9 по массиву
Maссив : [4 33 41 48 52 57 85 90 93 98]

После прохода номер 10 по массиву
Maссив : [4 33 41 48 52 57 85 90 93 98]
```

[Вернуться к оглавлению](#оглавление)

## ***Сортировка алгоритмом шелла***
<div align="center">
  <img alt="Foto 1" src="Image/image6.png" width="300" height="400"/>
</div>

**Сортировка Шелла** — это алгоритм, при котором массив обрабатывается за несколько проходов с использованием определённых **интервалов (шагов)** между сравниваемыми элементами. На каждом этапе **массив сортируется вставками, но не между соседними элементами, а между элементами, отстоящими друг от друга на текущем интервале.** Алгоритм начинается с **крупных интервалов,** что позволяет элементам **быстро переместиться в нужном направлении,** преодолевая большие расстояния. После каждого прохода **интервал постепенно уменьшается,** пока не станет равным единице, что соответствует окончательной **обычной сортировке вставками.** Таким образом, на ранних этапах **эффективно ликвидируется беспорядок** в массиве, что в итоге повышает общую скорость сортировки.

```go
func Shella(arr []int) {
	fmt.Println("\n---Сортировка алгоритмом Шелла---")

	size := len(arr)
	gap := size / 2

	for gap > 0 {
		for i := gap; i < size; i++ {
			per := arr[i]
			j := i

			for j >= gap && arr[j-gap] > per {
				arr[j] = arr[j-gap]
				j -= gap
			}
			arr[j] = per
		}
		gap /= 2
	}

	fmt.Println("Отсортированный массив:", arr)
}
```

*Пример работы кода*

```
```

[Вернуться к оглавлению](#оглавление)

## ***Гномья сортировка***
<div align="center">
  <img alt="Foto 1" src="Image/image7.jpeg" width="600" height="300"/>
</div>

**Гномья сортировка** — алгоритм, при котором массив обрабатывается за один проход с использованием **всего одного цикла.** На каждом шаге **сравниваются два соседних элемента** — текущий и предыдущий. Если они находятся в верном порядке, алгоритм **"движется вперед"** к следующему элементу. Если порядок нарушен, элементы **меняются местами,** и алгоритм **"отступает на шаг назад."** Такой подход напоминает движение садового гнома, который проверяет и упорядочивает горшки с цветами, продвигаясь вперед при правильном порядке и возвращаясь назад после каждого обмена. Таким образом, массив **постепенно упорядочивается слева направо,** пока все элементы не будут отсортированы.

[Вернуться к оглавлению](#оглавление)

## ***Быстрая сортировка***
<div align="center">
  <img alt="Foto 1" src="Image/image7.png" width="400" height="300"/>
</div>

```go
func quickSort(arr []int, low, high int) {
	if low < high {
		pivotIndex := partition(arr, low, high)
		quickSort(arr, low, pivotIndex-1)
		quickSort(arr, pivotIndex+1, high)
	}
}

func partition(arr []int, low, high int) int {
	mid := low + (high-low)/2
	
	if arr[low] > arr[mid] {
		arr[low], arr[mid] = arr[mid], arr[low]
	}
	if arr[low] > arr[high] {
		arr[low], arr[high] = arr[high], arr[low]
	}
	if arr[mid] > arr[high] {
		arr[mid], arr[high] = arr[high], arr[mid]
	}
	
	pivot := arr[mid]
	
	arr[mid], arr[high-1] = arr[high-1], arr[mid]
	
	i := low
	j := high - 1
	
	for {
		for i < high && arr[i] < pivot {
			i++
		}

		for j > low && arr[j] > pivot {
			j--
		}

		if i >= j {
			break
		}

		arr[i], arr[j] = arr[j], arr[i]
		i++
		j--
	}
	arr[i], arr[high-1] = arr[high-1], arr[i]
	
	return i
}
```

*Что происходит*
<div align="center">
  <img alt="Gif 4" src="Image/gif4.gif" width="700" height="300"/>
</div>

[Вернуться к оглавлению](#оглавление)

## ***Заключение***

<div align="center"><b>Сравнение сортировок</b> </div>

|*Сортировка*|*Сложность*|*Память*|*Стабильность*|*n = 1000*|*n = 10000*|*n = 100000*|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|Пузырьковая|O(n²)|O(1)|✅|855700 ns|35649200 ns|10156168200 ns|
|Шейкерная|O(n²)|O(1)|✅|543300 ns|29440800 ns|7761250000 ns|
|Вставками|O(n²)|O(1)|✅|545800 ns|7160500 ns|802359200 ns|
|Гномья|O(n²)|O(1)|✅|...|...|...|
|Выбором|O(n²)|O(1)|❌|520400 ns|31290600 ns|2408448800 ns|
|Шелла|O(n log²n)|O(1)|❌|0 ns|0 ns|15191700 ns|
|Быстрая|O(n log n)|O(log n)|❌|0 ns|0 ns|15856100 ns|
---

**Пузырьковая** - последовательное сравнение и обмен соседних элементов, "всплытие" максимумов

**Шейкерная** - двунаправленная версия пузырьковой сортировки с проходами слева-направо и справа-налево 

**Вставками** - построение отсортированной части массива путем вставки элементов в нужную позицию 

**Выбором** - поиск минимального элемента в неотсортированной части и обмен с текущей позицией 

**Шелла** - сортировка вставками с предварительной групповой сортировкой на больших расстояниях 

**Гномья** - алгоритм с одной петлей, попарно обменивающий элементы при движении вперед-назад  

**Быстрая** - стратегия "разделяй и властвуй" с выбором опорного элемента и рекурсивным разделением

[Вернуться к оглавлению](#оглавление)

[Вернуться на главную страницу](/README.md)

<div align="center">
  <img alt="Foto 1" src="Image/image8.png" width="600" height="400"/>
</div>

---

<div align="center"> Made with ❤️ by <b>l1m3ow</b> </div>